\documentclass[12pt,a4paper,openany]{report}
%%%% JNLP 
\usepackage{lmodern}
\usepackage{xcolor}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage[top=1.7cm, bottom=1.7cm, left=1.5cm, right=1.5cm]{geometry}
\usepackage{pdfpages}
\usepackage{listingsutf8}
\usepackage{fancyhdr}
\usepackage{multido}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{ifthen}
\usepackage{makeidx}
\usepackage[urlbordercolor={1 1 1}, linkbordercolor={1 1 1}, urlcolor=blue]{hyperref}
\usepackage{wrapfig}

%\newCommand{\footGauche}{} Université paul sabatier Toulouse III
\newcommand{\footCentre}{}
%\newCommand{\footDroite}{} Numéro de page
\newcommand{\premierDestinataire}{Monsieur Max \bsc{Chevalier}}
\newcommand{\rolePremierDestinataire}{Responsable projets}

\newcommand{\secondDestinaire}{Monsieur Thierry \bsc{Millan}}
\newcommand{\roleSecondDestinaire}{Client}

\newcommand{\troisiemeDestinaire}{Madame Caroline \bsc{Kross}}
\newcommand{\roleTroisiemeDestinaire}{Tutrice}

\newcommand{\quatriemeDestinaire}{}
\newcommand{\roleQuatriemeDestinaire}{}

\newcommand{\cinquiemeDestinaire}{}
\newcommand{\roleCinquiereDestinaire}{}
\newcommand{\titreDocument}{Analyse et conception}


\input{../couverture_entete.tex}
\begin{document}
%\setcounter{tocdepth}{4}
	\maketitle
	\newpage
	\tableofcontents
	\newpage
	\chapter{Spécification des besoins}
	\section{Objectifs, champ d'application, limites du système}
	La demande de ce système émane de Monsieur Thierry \bsc{Millan}, enseignant à l'IUT A Toulouse et chercheur
	à l'IRIT, qui nous a demandé la création d'une bibliothèque d'objets graphiques représentant
	les différents éléments de modélisation de la norme UML 2 en suivant un modèle de développement incrémental.
	La particularité de cette bibliothèque etant de respecter la norme UML 2 ce qui impose des restrictions
	d'utilisation sur chacun des éléments graphiques utilisés.

	Cette bibliothèque d'objets graphiques doit comprendre l'ensemble des éléments graphiques composant
	les principaux diagrammes utilisés dans la norme UML afin d'être utilisable par toutes les personnes
	participant à la production d'un projet. % Mouais.... 
	
	Suivant la demande du client, nous nous sommes limités aux 3 diagrammes principaux de la norme UML 2 :
	diagramme de cas d'utilisation, de classe et de séquence.

	Nous avons choisi de developper notre projet en utilisant la bibliothèque JGraphX
	qui est une bibliothèque graphique contenant une multitude d'éléments permettant
	par exemple de dessiner facilement des graphes ou des organigrammes. De plus, elle intègre les principaux 
	pictogrammes que l'on retrouve dans les différents diagrammes UML tels que les cas d'utilisation (ellipse)
	ou les acteurs (bonhomme).

	\subsection{Fonctionnalités du système}
	\begin{itemize}
		\item Permettre de dessiner un \glo{diagramme de classe}{Diagramme de classe}{Schéma utilisé en
			génie logiciel pour représenter les classes et les interfaces des systèmes ainsi que les différentes
			relations entre celles-ci.}.
		\item Permettre de dessiner un \glo{diagramme de séquence}{Diagramme de séquence}{
			Représentation graphique des interactions entre les acteurs et le système
	selon un ordre chronologique. Ce diagramme est inclus dans la partie dynamique d'UML.}.
		\item Permettre de dessiner un diagramme de cas d'utilisation.
		\item Permettre de restreindre l'utilisation des éléments graphiques aux seuls diagrammes dans lesquels ils sont utilisés.
	\end{itemize}
	\subsection{Etats de sortie du système}
	D'autres logiciels utiliseront la bibliothèque en tant que composant, la bibliothèque graphique
	permettra à chaque utilisateur d'intégrer séparément chaque objet graphique dans d'autres projets,
	et ainsi être réutilisée dans d'autres objectifs ou en association avec d'autres composants.
	Par conséquent le système n'a pas d'états de sortie à proprement parler.\\
	Néanmoins nous avons développé un démonstrateur parallèlement au projet dans le but de démontrer
	le bon fonctionnement de notre système.
	Ce dernier, utilise notre bibliothèque d'objet graphique et a pour états de sortie la représentation
	graphique à l'écran des différents diagrammes UML dessinés. % screen !

	\section{Besoins non-fonctionnels}
		\paragraph{En efficacité :}
		Temps de réponse - Le temps de réponse doit être suffisament rapide pour permettre une utilisation fluide du système.
		Consomation de mémoire - Le système ne doit pas consommer plus de 200 Mo de mémoire vive.
		\paragraph{En implémentation :}
		Propreté du code - Le nombre cyclomatique ne doit pas dépasser 15.
		\paragraph{En interopérabilité :}
		La capture des erreurs d'entrée-sortie - comment traiter les échecs d'interface électroniques, etc.
		Le traitement des mauvaises données - import de données, marquer-et-continuer ou arrêt la politique d'importation, etc.
		Intégrité des données - intégrité référentielle dans tables de base de données et interfaces
		\paragraph{En compatibilité :}
		La compatibilité avec des applications utilisant le système en tant que composant - Le système doit être facilement
		utilisable par des applications extérieurs qui l'utiliserait comme composant.
		La compatibilité sur des systèmes d'exploitation différents. Le système doit être capable de fonctionner sur les 
		systèmes d'exploitations les plus courant (Windows, Mac OS, Linux).
		\paragraph{En ergonomie :}
		Les standards d'ergonomie - la densité d'éléments sur les écrans, la disposition et le flux, les couleurs, l'Interface 
		Utilisateur et les raccourcis clavier doivent correspondre aux normes d'ergonomie.
		Internationalisation / besoins de localisation - Le système doit pouvoir être utilisé par des utilisateurs de nationalité autre que française.
		\paragraph{En documentation :}
		Eléments de documentation requis - Le système doit être suffisament documenter pour être compréhensible rapidement.
	\chapter{Conception}
	\section{Architecture générale du projet}
		L'architecture est la base d'une conception telle que nous l'avons choisie. En utilisant la notation UML, 
		nous sommes parvenu à élaborer un ``meta-modèle'' de cette notation mais en isolant uniquement l'aspect 
		graphique, faisant ainsi abstraction des multipes règles de conception que la norme UML impose. Après 
		discussion avec le client, de nombreuses modifications ont été apportées à l'archetecture d'origine 
		pour aboutir à une solution stable. Cette nouvelle architecture se compose de vingt classes, réparties 
		en quatre paquetages comme suit :
	\newline
	\begin{wrapfigure}{r}{9cm}
		Dans cet arbre représentant notre architecture, on peut voir certains noms \textbf{en gras} ou \textit{en italique}. 
		Les noms \textbf{en gras} représentent les différents paquetages que nous avons séparés. Ceux \textit{en italiques} 
		sont des classes abstraites crées afin de factoriser le code dans l'optique de réaliser une programmation objet optimale 
		et de suivre les objectifs de propreté du code imposés par le client.\vspace{2px}
		
		Dans un premier temps, nous avons séparer les diagrammes des éléments graphiques. En effet, un diagramme sera composé de
		toute sorte d'éléments graphiques. Puis nous avons découper ces derniers en deux, isolant ainsi les lignes des elements
		de modélisation tels que les classes, les traitements ou les cas d'utilisation.\vspace{2px}
		
		\textit{ElementGraphique} et \textit{ElementModelisation} sont des classes abstraites car elle regroupe les fonctions communes
		à toues les lasses de leur paquetage respectifs sans pour autant en fournir une implémentation de chacune d'elles -- comme par exemple la méthode qui crée la
		représentation graphique d'un élément ou celle qui permet de le supprimer d'un diagramme.
	\end{wrapfigure}
	% Arbre de classe
	\begin{itemize}
		\item \textbf{eltGraphique}
			\begin{itemize}
				\item \textit{ElementGraphique}
				\item \textbf{eltModelisation}
					\begin{itemize}
						\item \textit{Acteur}
						\item ActeurActif
						\item ActeurPassif
						\item Attribut
						\item CasUtilisation
						\item Classe
						\item \textit{ElementModelisation}
						\item Interface
						\item Methode
						\item Traitement
						\item Visibilite
						\item Variable
					\end{itemize}
				\item \textbf{ligne}
					\begin{itemize}
						\item Cardinalite
						\item Lien
						\item MessageTraitement
						\item TypeLien
					\end{itemize}
			\end{itemize}
		\item \textbf{diagramme}
			\begin{itemize}
				\item Diagramme
				\item DiagrammeCasUtilisation
				\item DiagrammeClasse
				\item DiagrammeSequence
			\end{itemize}
	\end{itemize}
	\newpage 
	Prenons maintenant chaque paquetage séparément 
	\subsection{Package eltGraphique}
	Le paquetage eltGraphique regroupe toutes les classes qui représentent des éléments graphiques. Il regroupe la classe 
	\textit{ElementGraphique} et deux paquetages \textbf{eltModelisation} et \textbf{ligne}. Cette classe possède deux attributs 
	\texttt{graph} et \texttt{diagramme}, correspondant repectivement au graphe dans lequel sont stockés les éléments 
	et le diagramme afficher à l'écran. Elle comprend également (en plus d'un constructeur initialisant les attributs) 
	les méthodes \texttt{supprimer} permettant de supprimer un élément du graphe et du diagramme, ainsi que \texttt{creer}, 
	méthode abstraite réimplémentée dans les classes descendentes servant à creer la représentation graphique de l'objet 
	et l'afficher sur le diagramme.
	\paragraph{Package eltModelisation} Ce paquetage regroupe toutes les classes représentant les différents éléments de 
	modélisation que l'on trouver dans les diagrammes UML de cas d'utilisation, classe et de séquence. \textit{Acteur} 
	est une classe abstraite car les acteur actif et passifs ont beaucoup de caractéristiques identiques mais n'ont pas 
	la même représentation sur un diagramme. Les classes Visibilite, Methode et Attribut permettent au client de créer 
	facilement une interface de saisie de ces éléments, facilitant l'usage du logiciel final. De plus, l'ajout de ces 
	méthodes et attributs dans des classes, des acteurs des traitements ou des interfaces pourra faciliter l'ajout futur 
	de nouvelle fonctionnalités comme apr exemple de la génération de code Java.
	\paragraph{Package ligne} Ce paquetage regroupe peu de classe. TypeLien est une classe énumérée servant à recenser
	toutes les types graphiques de liens existant dans la notation UML. Cardinalite quant à elle, permet comme Methode 
	ou Attribut, d'aider le client à permettre un saisie facilité des cardinalités d'un lien dans un diagramme de classe par exemple.
	La classe Lien comprend la méthode \texttt{creer} qui va configurer tous les styles de liens et applique au nouveau lien
	le style choisi par l'utilisateur. MessageTraitement spécialise Lien, permettant de créer un style de lien particulier
	aux massages entre traitement dans les diagrammes de séquences.
	\subsection{Package diagramme}
	La paquetage \textbf{diagramme} comprend plusieurs type de diagramme prédéfinis qui sont cas d'utilisation, classe et séquence.
	Ils descendent de la classe Diagramme. Chaque type de diagramme implémente deux méthode \texttt{eltAutorise} et \texttt{lienAutorise}
	qui permettent respectivement d'autoriser ou interdire un type d'élément particulier et un type de lien entre deux types d'éléments
	particuliers. La classe Diagramme est générique. Par défaut elle autorise tous les éléments et tous les liens. Il est donc possible
	au client de réimplémnter ses propres méthodes pour créer ses propres règles.

	\subsection{Conception détaillée}
	La description détaillée des méthodes et des attributs de chaque classe est disponible sous forme papier dans le dossier spécifié à la
	documentation ou à l'adresse \\
	$\rhd$ \url{http://documentation.joohoo.fr/libUML}
	
	\chapter{Glossaire}
	\begin{sortedlist}
		\input{glossaire.tex}
	\end{sortedlist}
\end{document}
