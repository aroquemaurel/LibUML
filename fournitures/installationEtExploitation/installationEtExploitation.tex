\documentclass[12pt,a4paper,oneside]{book}
\usepackage{lmodern}
\usepackage{xcolor}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage[top=1.7cm, bottom=1.7cm, left=1.5cm, right=1.5cm]{geometry}
\usepackage{pdfpages}
\usepackage{listingsutf8}
\usepackage{fancyhdr}
\usepackage{multido}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{ifthen}
\usepackage{wrapfig}
\usepackage{makeidx}
\usepackage[urlbordercolor={1 1 1}, linkbordercolor={1 1 1}, urlcolor=blue]{hyperref}
\usepackage{float}

\newcommand{\footCentre}{}
\newcommand{\premierDestinataire}{Monsieur Thierry Millan}
\newcommand{\rolePremierDestinataire}{Client}

\newcommand{\secondDestinaire}{Madame Caroline Kross}
\newcommand{\roleSecondDestinaire}{Tutrice}

\newcommand{\troisiemeDestinaire}{}
\newcommand{\roleTroisiemeDestinaire}{}

\newcommand{\quatriemeDestinaire}{}
\newcommand{\roleQuatriemeDestinaire}{}

\newcommand{\cinquiemeDestinaire}{}
\newcommand{\roleCinquiereDestinaire}{}

\newcommand{\titreDocument}{Installation et exploitation}


\input{../couverture_entete.tex}
\input{../listings.tex}
\begin{document}
	\maketitle
	\setcounter{tocdepth}{1}
	\setcounter{secnumdepth}{3}
	\frontmatter
	\input{intro.tex}
	\tableofcontents
	\nouveauChapitre
	\newpage
	\mainmatter
	\chapter{Le démonstrateur}
	\section{Interface Homme Machine}
	\nouveauChapitre
	Nous avons développé un démonstrateur afin que vous puissiez comprendre comment fonctionne la bibliothèque, et pour montrer ses possibilités.
	Ainsi, tout ce qu'il est possible de faire avec la bibliothèque sera présent dans le démonstrateur.

	Dans cette partie nous allons passer brièvement ses fonctionnalités, cependant, pour une meilleure
	compréhension, nous avons commentés le code du démonstrateur pour qu'il soit le plus simple possible et pour que vous ayez le moins 
	possible de vous référez à ce document. La documentation est également disponible au format javadoc comme signalé en Avant-propos page \pageref{docDemonstrateur}.
	\paragraph{}	
	Le démonstrateur est volontairement simple, il n'a pas pour but d'être lourd, mais uniquement de montrer les possibilités de la bibliothèque. 
	Il est disposé en trois parties:
	\begin{enumerate}
		\item En haut, la barre d'outils, permettant de sélectionner l'élément graphique souhaité
		\item Au centre, ce que nous appelons le graphe, c'est ici qu'apparaîtrons les diagrammes UML
		\item À droite, un panneau contenant éventuellement un tableau avec les informations de la classe sélectionnée, mais aussi le type de diagramme choisit
	\end{enumerate}
	\begin{figure}[H]
		\centering
		\includegraphics[width=15cm]{screen1.jpg}
		\caption{Les différentes parties du démonstrateur}
	\end{figure}
	Au démarrage du démonstrateur, il faut choisir le type de contrainte souhaité, cela aura pour effet d'interdire l'ajout de certains éléments.
	%%%
	%%% //TODO ici mettre un screen du démonstrateur.
	%%%
	\subsection{La barre d'outils}
	La barre d'outils contient tous les éléments graphiques que permet notre bibliothèque.
	\subsubsection{Élément de modélisation}
	Il est actuellement possible de faire les éléments de modélisation suivants:
	\begin{itemize}
		\item Acteur actif
		\item Acteur passif
		\item Traitement
		\item Cas d'utilisation
		\item Classe
		\item Interface
	\end{itemize}
	Le clic sur un bouton positionnera un élément de modélisation dans le graphe.\\

	\subsubsection{Liens}
	La deuxième partie de la barre d'outils contient tous les liens qu'il est possible de faire.
	\begin{itemize}
		\item Association
		\item Dépendance fonctionnelle
		\item Généralisation
		\item Agrégation
		\item Composition
	\end{itemize}
		Pour relier deux éléments, vous devez cliquer sur la flèche voulut, puis cliquer sur les deux éléments à relier. 
	Le clic sur les deux éléments aura pour effet de créer un lien.
	\subsection{Le graphe}
	Le graphe contient tous les éléments graphiques, l'affichage d'un élément se fera donc dans le graphe. 
	C'est également dans le graphe que s'affiche le menu contextuelle permettant d'interagir avec les éléments.

	Le graphe est également important dans la programmation comme nous le verrons section \ref{mxGraph} page \pageref{mxGraph}.

	\subsection{Le menu contextuel}
	Le menu contextuel s'affiche au clic droit sur un élément graphique, celui-ci diffère quelque peut suivant l'élément. 
		\subsubsection{Les acteurs (actifs ou passifs)}
		Il est possible d'afficher, ou non la ligne de vie, celle ci étant utile pour les diagrammes de séquence.
		\subsubsection{Les classes}
		Il vous est possible d'ajouter des méthodes ou des attributs, ces méthodes et attributs une fois inséré s'afficheront dans le tableau sur la droite.\\
		Il est également possible de générer une interface, la classe implémentant cette interface.
		\subsubsection{Les traitements}
		Vous pouvez afficher ou non la flèche symbolisant le début d'une séquence.
		\subsubsection{Tous les éléments graphiques}
		Pour tous les éléments graphiques, il est possible de les supprimer. La suppression d'un élément entrainera la suppression de tous les liens qui s'y raccrochent.

	\section{L'architecture}
	Le démonstrateur est fait de multiple paquetages, nous allons les détailler ici.
	\begin{wrapfigure}{l}{5cm}
	\begin{itemize}
		\item \policePackage{evenements}
			\begin{itemize}
				\item \policePackage{btn}
					\begin{itemize}
						\item \policePackage{toolbar}	
					\end{itemize}
				\item \policePackage{menu}
					\begin{itemize}
						\item \policePackage{contextuel}
						\item \policePackage{fichier}
					\end{itemize}
			\end{itemize}
		\item \policePackage{ihm}
			\begin{itemize}
				\item \policePackage{fenetreClasses}
				\item \policePackage{fenetreInterdiction}
				\item \policePackage{menu}
			\end{itemize}
		\end{itemize}
	\end{wrapfigure}
	Le démonstrateur est donc construit entre deux paquetages principaux \policePackage{ihm} et \policePackage{evenements}. 
	\paragraph{}	

	\policePackage{ihm} est le paquetage ne servant qu'à l'affichage et la création des différentes fenêtre(\texttt{FenetreDemo}, \texttt{FenetreInterdiction}, \texttt{FenetreAjoutAttribut}, \ldots) mais aussi des menus (\texttt{BarreMenus}, \texttt{BarreOutilsDessin}, \ldots).
	Ce paquetage à ensuite des sous paquetages, classant les fenêtres concernant une classe d'un cotés (\texttt{FenetreAjoutAttribut} par exemple), les fenêtres d'interdiction
	lorsque nous ne pouvons créer ou relier deux éléments, et ensuite les différents menus. À la racine du paquetage \policePackage{ihm} sont positionnés 
	les classes servant à l'affichage de la fenêtre principale.
	\paragraph{}
	\policePackage{evenements} quant à lui ne s'axera que sur les évènements qui peuvent avoir lieu dans le démonstrateur, c'est dans ce paquetage que sont crée
	tous les boutons, et que l'action sur un bout sera traité.

	Dans ce paquetage, nous pouvons donc trouver des sous paquetages pour les boutons, les boutons présents dans la barre d'outils, le menu contextuel, la barre de menus, les
	événements sur une cellule.

	\chapter{La bibliothèque UML}	
	\nouveauChapitre
	La bibliothèque UML est basée sur \texttt{JGraphX} cependant, aucune connaissance de cette bibliothèque est indispensable pour se servir de libUML. En effet, son 
	utilisation est volontairement simple, une fois que vous avez acquis les concepts.
	\section{L'architecture}
	\begin{wrapfigure}{l}{7cm}
	\begin{tikzpicture}
		\draw (0,0.0) -- (0,-10.2) ;
		\draw (0.0,-0.0) -- (1.50,-0.0) ;
		\draw (0.0,-10.2) -- (1.50,-10.2) ;
		\node at (1.5,0.2) {\policePackage{eltGraphique}} ;
		\node at (2.0,-0.3) {\textit{ElementGraphique}} ;
		\node at (2.0,-0.7) {\policePackage{eltModelisation}} ;
		\draw (0.3,-1.1) -- (0.3,-7.0) ;
		\draw (0.3,-1.1) -- (0.80,-1.1) ;
		\draw (0.35,-7.0) -- (0.85,-7.0) ;
		\node at (1.27,-1.3) {\textit{Acteur}} ;
		\node at (1.74,-1.7) {ActeurActif} ;
		\node at (1.84,-2.2) {ActeurPassif} ;
		\node at (1.45,-2.7) {Attribut} ;
		\node at (1.99,-3.2) {CasUtilisation} ;
		\node at (1.33,-3.7) {Classe} ;
		\node at (2.6,-4.2) {\textit{ElementModelisation}} ;
		\node at (1.58,-4.7) {Interface} ;
		\node at (1.58,-5.2) {Methode} ;
		\node at (1.75,-5.7) {Traitement} ;
		\node at (1.6,-6.2) {Visibilite} ;
		\node at (1.55,-6.7) {Variable} ;

		\node at (0.9,-7.7) {\policePackage{ligne}} ;
		\draw (0.3,-8.0) -- (0.3,-10.0) ;
		\draw (0.3,-8.0) -- (0.80,-8.0) ;
		\draw (0.3,-10) -- (0.80,-10) ;
		\node at (1.85,-8.3) {Cardinalite} ;
		\node at (1.25,-8.8) {Lien} ;
		\node at (2.57,-9.3) {MessageTraitement} ;
		\node at (1.70,-9.8) {TypeLien} ;
		\node at (1.0,-10.8) {\policePackage{diagramme}} ;

		\draw (0.0,-11.0) -- (0.0,-13.0) ;
		\draw (0.0,-11.0) -- (0.50,-11.0) ;
		\draw (0.0,-13.0) -- (0.50,-13.0) ;
		\node at (1.4,-11.3) {Diagramme} ;
		\node at (2.7,-11.8) {DiagrammeCasUtilisation} ;
		\node at (2.0,-12.3) {DiagrammeClasse} ;
		\node at (2.25,-12.8) {DiagrammeSequence} ;
	\end{tikzpicture}
	\end{wrapfigure}
		L'architecture est la base d'un projet comme le notre, car il sera repris et amélioré par d'autres étudiants. 
		En utilisant la notation UML, nous sommes parvenus à élaborer un ``méta modèle'' de cette notation mais
		en isolant uniquement l'aspect graphique, faisant ainsi abstraction des multiples règles de conception que la norme UML impose.
		Après discussion avec le client, de nombreuses modifications ont été apportées à l'architecture d'origine 
		pour aboutir à une solution stable. Cette nouvelle architecture se compose de vingt classes, réparties 
		en quatre \glo{paquetages.}{Paquetage}{Un paquetage en Java est un regroupement de classes ayant la même thématique.}\\ 

		Dans cet arbre représentant notre architecture, on peut voir certains noms écrits en \policePackage{gras}. 
		ou en \textit{italique}. 
		Les noms en \policePackage{gras} représentent les différents paquetages que nous avons séparés.
		
		Ceux en \textit{italiques} sont des classes abstraites crées afin de factoriser le code dans l'optique de réaliser une programmation objet optimale 
		et de suivre les objectifs de propreté du code imposés par le client.\vspace{2px}
	\paragraph{}	
		Dans un premier temps, nous avons séparé les diagrammes des éléments graphiques. En effet, un diagramme sera composé de
		toute sorte d'éléments graphiques. Puis nous avons découpé ces derniers en deux, isolant ainsi les lignes des éléments
		de modélisation tels que les classes, les traitements ou les cas d'utilisation.\vspace{2px}
		
		\texttt{ElementGraphique} et \texttt{ElementModelisation} sont des classes abstraites qui regroupent les fonctions communes
		à toutes les classes de leur paquetage respectifs sans pour autant en fournir une implémentation de chacune d'elles -- comme par exemple la méthode qui crée la
		représentation graphique d'un élément ou celle qui permet de le supprimer d'un diagramme.\\ 
	Prenons maintenant chaque paquetage séparément pour voir comment ils fonctionnent plus en détails.
	% Arbre de classe
	\subsection{Paquetage eltGraphique}
	Le paquetage \policePackage{eltGraphique} regroupe toutes les classes qui représentent des éléments graphiques. Il regroupe la classe 
	\textit{ElementGraphique} et deux paquetages \policePackage{eltModelisation} et \policePackage{ligne}. Cette classe possède deux attributs 
	\texttt{graph} et \texttt{diagramme}, correspondant respectivement au graphe dans lequel sont stockés les éléments 
	et le diagramme affiché à l'écran. Elle comprend également (en plus d'un constructeur initialisant les attributs) 
	les méthodes \texttt{supprimer} permettant de supprimer un élément du graphe et du diagramme, ainsi que \texttt{creer}, 
	méthode abstraite réimplémentée dans les classes descendantes servant à créer la représentation graphique de l'objet 
	et de l'afficher sur le diagramme.
	\paragraph{Paquetage eltModelisation} Ce paquetage regroupe toutes les classes représentant les différents éléments de 
	modélisation que l'on trouve dans les diagrammes UML de cas d'utilisation, classes et de séquence. \textit{Acteur} 
	est une classe abstraite car les acteur actifs et passifs ont beaucoup de caractéristiques identiques mais n'ont pas 
	la même représentation sur un diagramme. Les classes \texttt{Visibilite}, \texttt{Methode} et \texttt{Attribut} permettent au client de créer 
	facilement une interface de saisie de ces éléments, facilitant l'usage du logiciel final. De plus, l'ajout de ces 
	méthodes et attributs dans des classes, des acteurs, des traitements ou des interfaces pourra faciliter l'ajout futur 
	de nouvelles fonctionnalités comme par exemple de la génération de code \glo{Java}{Java}{Langage de programmation orienté objet moderne, il compile le programme pour ensuite l'exécuter sur une machine Java, ainsi le programme une fois compilé peut être exécuté sur différentes plateformes (Windows, Linux, Mac OS X, \ldots).}.
	\paragraph{Paquetage ligne} Ce paquetage regroupe peu de classe. \texttt{TypeLien} est une classe énumérée servant à recenser
	tous les types graphiques de liens existant dans la notation UML. \texttt{Cardinalite} quant à elle, permet comme \texttt{Methode} 
	ou \texttt{Attribut}, d'aider le client à permettre un saisie facilité des cardinalités d'un lien dans un diagramme de classe par exemple.
	La classe \texttt{Lien} comprend la méthode \texttt{creer} qui va configurer tous les styles de liens et appliquer au nouveau lien
	le style choisi par l'utilisateur. \texttt{MessageTraitement} spécialise Lien, permettant de créer un style de lien particulier
	aux messages entre traitement dans les diagrammes de séquences.
	\subsection{Paquetage diagramme}
	La paquetage \policePackage{diagramme} comprend plusieurs type de diagramme prédéfinis qui sont cas d'utilisation, classes et séquence.
	Ils descendent de la classe \texttt{Diagramme}. Chaque type de diagramme implémente deux méthodes \texttt{eltAutorise} et \texttt{lienAutorise}
	qui permettent respectivement d'autoriser ou interdire un type d'élément particulier et un type de lien entre deux types d'éléments
	particuliers. La classe Diagramme est générique. Par défaut elle autorise tous les éléments et tous les liens. Il est donc possible
	au client de réimplémenter ses propres méthodes pour créer ses propres règles.
	\section{Le graphe} \label{mxGraph}
	Le graphe est très important dans la bibliothèque, c'est là où l'élément va s'afficher, ainsi chaque élément graphique doit avoir un \texttt{mxGraph}, pour la bibliothèque
	UML un seul graphe existe et tous les éléments sont dans le même graphe.
	\subsection{mxGraphComponent}
	\texttt{mxGraphCompnent} est un panneau contenant le graphe, cela peut vous permettre de dimensionner votre graphe, d'afficher une grille et d'autres choses
	intéressantes, pour paramètres votre graphe, nous vous conseillons d'aller voir la documentation de \texttt{JGraphX} donnée à l'Avant-propos page \pageref{docDemonstrateur}.
	\subsection{mxGraphControl}
	La classe \texttt{mxGraphControl} (accessible via mxGraphComponent) permet d'ajouter un listener sur les cellules et ainsi pouvoir interagir avec les cellules comme
	afficher un menu contextuel par exemple. Si vous voulez sélectionner un élément graphique présent sur le graphe, vous devrez utiliser deux méthodes. 
	\begin{itemize}
		\item La méthode \texttt{getSelectedCell()} qui permet de récupérer une \texttt{mxCell}
		\item La méthode \texttt{getElementGraphiqueViaCellule(mxCell)} qui récupère un élément graphique correspondant à la cellule.
	\end{itemize}
	\section{Le diagramme}
	Le diagramme permet deux choses:
	\begin{itemize}
		\item Il contient tous les éléments graphiques ajoutés dans le graphe, dans un approche de long terme, cela pourrait être utile pour faire une sauvegarde par exemple.
		\item Il peut permettre de restreindre des actions pour respecter la norme UML. Il vous est possible de redéfinir Diagramme pour refaire vos propres contraintes, 
			mais aussi d'utiliser des contraintes déjà faites pour le diagramme de Classe, diagramme de séquence et diagramme de cas d'utilisation.
	\end{itemize}

	\section{Les éléments de modélisation}
	\subsection{Le constructeur}
	Voici le constructeur d'un élément de modélisation classique: 
	\begin{lstlisting}[language=Java]
ElementModelisation(mxGraph, Diagramme, String, Dimension, Position);
	\end{lstlisting}
	\begin{itemize}
		\item \texttt{mxGraph} -- Le graphe dans lequel apparaitra l'élément.
		\item \texttt{Diagramme} -- Le diagramme dans lequel est l'élément, cela peut aussi servir de contrainte.
		\item \texttt{String} -- Le texte qui apparaitra dans l'élément de modélisation (la position de la chaîne de caractère varie en fonction de l'élément de modélisation)
		\item \texttt{Dimension} -- La dimension de l'élément
		\item \texttt{Position} -- La position de l'élément
	\end{itemize}
	\subsection{Création de l'élément}
	Pour créer un élément, il suffit d'abord de l'instancier, et ensuite d'appeler la méthode \texttt{creer()}.
	\subsection{Suppression d'un élément} 
	Pour supprimer un élément, vous pouvez appeler la méthode \texttt{supprimer()} qui supprimera l'élément et tous les liens attachés.\\
	Attention, cela ne supprime que la cellule (\texttt{mxCell}), si vous voulez supprimer totalement l'objet, vous devez mettre l'élément graphique à \texttt{null}.
	\section{Les liens}
	La création de lien est ressemble à la création d'un élément de modélisation étant donné que \texttt{Lien} et \texttt{ElementModelisation} héritent tout deux
	de \texttt{ElementGraphique}. 
	\subsection{Constructeur}
	\begin{lstlisting}[language=Java]
Lien(ElementModelisation, ElementModelisation, mxGraph, Diagramme, 
		TypeLien);
	\end{lstlisting}
	Les deux premiers paramètre correspondent à la source et à la destination du lien, les deux suivants sont le graphe et le diagramme comme précédemment, le 
	dernier est une énumération des types de liens gérés par la bibliothèque.
	\subsection{Création d'un lien}
	Il faut instancier le lien, avec la source et la destination. Ensuite, de la même manière que précedemment, il faut faire appel à la méthode \texttt{creer()}.
	\subsection{Suppression d'un lien}
	La suppresion d'un lien se faire via la méthode \texttt{supprimer()}. \\
	Attention, cela ne supprime que la cellule (\texttt{mxCell}), si vous voulez supprimer totalement l'objet, vous devez mettre l'élément graphique à \texttt{null}.


	\section{Exemple}
	\lstinputlisting[language=Java, caption=Exemple d'utilisation de libUML]{exemple.java}
	Cet exemple est volontairement simple pour vous permettre de comprendre le fonctionnement de la bibliothèque.
	\chapter{Poursuite de développement de la bibliothèque}				
	\nouveauChapitre
	\section{JGraphX}
	La bibliothèque utilise entièrement \texttt{JGraphx} pour dessiner les composants. Nous avons fait en sorte qu'un utilisateur voulant se servir de libUML
	n'ai nullement besoin de la connaissance de \texttt{JGraphx}, ainsi, il faut restreindre l'utilisation de \texttt{JGraphx} au strict minimum (\texttt{mxGraph}\ldots) quitte
	à redéfinir des fonctions appelant la fonction parente, ça à l'avantage d'intégrer la Javadoc de cette méthode à la documentation du projet.

	La bibliothèque \texttt{JGraphx} à le grand défaut de n'avoir qu'une toute petite communauté, ainsi, vous trouverez rarement des réponses à votre problème
	sur un forum, nous avons donc beaucoup utilisé la documentation (Javadoc et manuel), cette documentation est accessible ici: 
	\section{Création d'un nouvel élément}
	Pour créer un nouvel élément, il faut créer une classe héritant de \texttt{ElementGraphique} ou \texttt{ElementModelisation}, redéfinir la méthode \texttt{creer}, dans cette méthode, le style doit être créé, c'est dans ce style que l'ont peut choisir la forme, la couleur, la possibilité de le déplacer etc\ldots 
	Comme ceci par exemple:
	\begin{lstlisting}[language=Java, caption=Création du style de l'acteur actif]
private void creerStyleActeurActif() {
	Map<String, Object> nouveauStyle = new HashMap<String, Object>();
	mxStylesheet feuilleStyles = super.getGraph().getStylesheet();
	
	nouveauStyle.put(mxConstants.STYLE_SHAPE, mxConstants.SHAPE_ACTOR); 
	/* opacité */
	nouveauStyle.put(mxConstants.STYLE_OPACITY, Constantes.OPACITE);
	/* couleur du texte */
	nouveauStyle.put(mxConstants.STYLE_FONTCOLOR, Constantes.COULEUR_TEXTE); 
	nouveauStyle.put(mxConstants.STYLE_STROKECOLOR, Constantes.COULEUR_BORDURE); //Couleur de la bordure
	/* Un élément peut s'inclure dans l'acteur*/
	nouveauStyle.put(mxConstants.STYLE_FOLDABLE, mxConstants.NONE); 
	
	/*Création du style avec les paramètres précédent */
	feuilleStyles.putCellStyle("ACTEUR_ACTIF", nouveauStyle); 
}
\end{lstlisting}
Pour créer un nouveau style de flèche, le principe est le même, il faut créer un style, sauf qu'il faut ajouter ce style de flèche dans l'énumeration, dans
le switch présent dans la classe \texttt{Lien}.\\
Cependant, nous n'avons pas trouvé comment changer la couleur de fond du bout de la flèche.
	
	\chapter{Conclusion du projet}
	\nouveauChapitre
	Le projet de départ étant une étude de faisabilité, nous pouvons donc en conclure que c'était tout à fait faisable, et que ce n'était pas très compliquée de pouvoir
	tracer des éléments de modélisation, nous avons cependant eu beaucoup de mal à trouver une architecture qui soit viable, ceci venant peut être aussi de notre manque
	d'experience. L'architecture à mis longtemps à être posée, mais je pense que maintenant elle semble stable.
	\section{Un outil UML complet ?}
	Après reflexion, nous pensons que développer un outil UML complet nous prendrait environ 6 mois, 
	en utilisant ce que nous avons déjà développé de notre bibliothèque. JGraphX nous permet de faire certaines choses vraiment simplement, pour certaines autre chose, cela
	est beaucoup plus dur, mais avec du temps, nous pensons que c'est faisable. 
	\section{Utilité à un outil fragmentée ?}
	Étant donné que nous sommes étudiants, et ne travaillons que sur des petits projets, nous n'avions pas tout de suite vu l'utilité d'un outil fragmentée, cependant
en effet, cela est utile pour de gros projets, ainsi, notre bibliothèque UML permettrai de réaliser ceci, grâce aux contraintes que nou avons mis en \oe{}uvre.
	
	\closeout\glossaireVar
	\appendix
	\chapter{Glossaire}\label{glossaire}
	\nouveauChapitre
	\begin{sortedlist}
		\input{glossaire.tex}
	\end{sortedlist}
	\chapter{Diagramme de classes}
	\nouveauChapitre
	\includepdf{paquetageSansMethodes.pdf}
	\chapter{Diagramme de paquetages}
	\nouveauChapitre
	\includepdf{classeSansMethodes.pdf}
\end{document}

